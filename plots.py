import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
import pickle
from typing import Union
import os
import functools
import matplotlib as mpl
import sys

'''
With this file, you can produce plots of the data generated by the simulation with penguins.py. The outputs are saved in directories automatically created if they don't exist yet.
Outputs are histograms of observables, a gifs of the positions of the particle positions and field values as a function of time, and a plot of the average absolute difference between the particle fields and the optimal temperature as a function of time.
'''

def set_defaults():
    ''' Set default values for matplotlib rcParams. '''
    # set default font size for axis labels
    mpl.rcParams['axes.labelsize'] = 16
    mpl.rcParams['xtick.labelsize'] = 12
    mpl.rcParams['ytick.labelsize'] = 12

    # set default legend font size
    mpl.rcParams['legend.fontsize'] = 12

def CatchFileNotFoundError(function):
    ''' Pick up FileNotFoundError and create the directory if it doesn't exist;
        if the error is not caused by a missing directory, raise the error '''

    @functools.wraps(function)
    def wrapper(*args, **kwargs):
        try:
            result = function(*args, **kwargs)
        except FileNotFoundError as e:
            path = str(e).split("'")[1]
            if os.path.isfile(path):
                raise e
            else:
                os.makedirs(os.path.dirname(path), exist_ok=True)
                result = function(*args, **kwargs)
        return result
    return wrapper

@CatchFileNotFoundError
def plot_positions_and_fields(total_positions:np.ndarray, particle_fields:np.ndarray, optimal_temp:float, filename:str, savesampling:int, timestep:float) -> None:
    ''' Plot the positions of the particles as a function of time in a video, with the color of the particles corresponding to the field value.
        Creates separate markers for each temperature in the case of two optimal temperatures.
        Saves the video as a gif in the 'gifs' directory.
    '''

    fig = plt.Figure(figsize=(8,8))
    ax = fig.add_subplot()
    fig, ax = plt.subplots(figsize=(8,8))
    def get_masked_data(temp, frame):
        mask = optimal_temp == temp
        current_step_x = total_positions[frame,:,0] ; current_step_y = total_positions[frame,:,1]
        temp_positions_x = current_step_x[mask] ; temp_positions_y = current_step_y[mask]
        temp_fields = particle_fields[frame,mask]
        return temp_positions_x.reshape(-1,), temp_positions_y.reshape(-1,), temp_fields.reshape(-1,)

    def update(frame):
        for i, temp in enumerate(unique_temps):
            temp_positions_x, temp_positions_y, temp_fields = get_masked_data(temp, frame)
            all_sc[i].set_offsets(np.column_stack((temp_positions_x, temp_positions_y)))
            all_sc[i].set_array(temp_fields - temp)
        text.set_text(f'Time: {frame * savesampling * timestep:.2f}')
        return sc, text,

    unique_temps = np.unique(optimal_temp)
    # give either temperature a unique marker in the case of two T_opt
    markers = ['o', 'x']
    all_sc = []
    for i, temp in enumerate(unique_temps):
        temp_positions_x, temp_positions_y, temp_fields = get_masked_data(temp, -1)
        sc = ax.scatter(temp_positions_x, temp_positions_y, c=temp_fields - temp, cmap='RdBu_r', s=10, marker=markers[i], vmin=-0.5, vmax=0.5, label=r'$T_{\mathrm{opt}}$ ='+f'{temp:.1f} [A$\kappa$]')
        all_sc.append(sc)
    text = ax.text(s='', x=0.5, y=1.05, ha='center', va='center', transform=ax.transAxes, fontsize=12)
    cbar = plt.colorbar(sc, ax=ax, label='T - T$_{opt}$', fraction=0.05)
    cbar.set_label('T - T$_{opt}$')
    ax.set_xlabel('x [$\kappa^{-1}$]')
    ax.set_ylabel('y [$\kappa^{-1}$]')
    ax.set_aspect('equal')
    ax.set_facecolor('black')
    ax.legend(loc='lower center', bbox_to_anchor=(0.5, -0.25), ncol=2)
    ax.set_xlim(0, np.sqrt(256))
    ax.set_ylim(0, np.sqrt(256))
    for handle in ax.legend_.legendHandles:
        handle.set_sizes([100])
        handle.set_color('black')
    frames_to_show = np.arange(0, total_positions.shape[0], 100 // savesampling)
    ani = FuncAnimation(fig, update, frames=frames_to_show)
    ani.save(f'gifs/{filename}.gif', writer='pillow', fps=10, dpi=200)
    plt.close()

@CatchFileNotFoundError
def plot_field_time(particle_fields:np.ndarray, optimal_temp:float, filename:str, savesampling:int, timestep:float) -> None:
    ''' Plot the average absolute difference between the particle fields and the optimal temperature as a function of time.
        The data is saved as a png in the 'figures' directory.
    '''
    fig, ax = plt.subplots()
    time = np.arange(particle_fields.shape[0]) * timestep * savesampling
    ax.plot(time, np.mean(np.abs(particle_fields - optimal_temp), axis=1))
    ax.set_xlabel('Time')
    ax.set_ylabel('<|T - T$_{opt}$|>')
    ax.set_yscale('log')
    plt.tight_layout()
    plt.savefig(f'figures/{filename}.png')
    plt.close()

@CatchFileNotFoundError
def plot_observables(particle_fields:np.ndarray, distances:np.ndarray, optimal_temp:float, filename:str, jitter:bool) -> None:
    ''' Plotting histograms of the observables 'distance to closest neighbour' and 'normalized temperature' next to each other
        for one run of the simulation.
        The outcome is saved as a png in the 'figures' directory.
    '''
    nearest_dists = distances
    delta_temp = particle_fields - optimal_temp

    fig, ax = plt.subplots(1, 2, figsize=(5,2.5), constrained_layout = True, sharey=True)
    ax[0].hist(delta_temp[-1,:]/optimal_temp)
    ax[0].set(xlabel='(T - T$_{opt}$) / T$_{opt}$', ylabel='counts')
    ax[1].hist(nearest_dists)
    ax[1].set(xlabel='nearest distance')
    if jitter:
        fig.suptitle(f'T$_{{opt}}$ = {np.unique(optimal_temp)[0], np.unique(optimal_temp)[1]}')
    else:
        fig.suptitle(f'T$_{{opt}}$ = {optimal_temp}')
    plt.savefig(f'figures/{filename}_observables.png')
    plt.clf()

    return 

@CatchFileNotFoundError
def plot_observables_together(name:str, jitter:bool):
    ''' If !jitter, the observables 'distance to closest neighbour' and 'normalized temperature' are plotted in histograms
        next to one another. If jitter, the observable 'temperature' is also plotted in a histogram next to these. In each plot,
        three distributions are plotted coming from three runs of the simulation with different initial positions.
        The outcome is saved as a png in the 'figures' directory.
    '''
    bins=80
    colors = ['red', 'blue', 'green']
    if jitter:
        fig, ax = plt.subplots(1, 3, figsize=(7.5,2.2), constrained_layout = True)
        for j,i in enumerate(['_run1.p', '_run2.p', '_run3.p']):
            filename = name + i
            total_positions, particle_fields, optimal_temp, _, _, _ = read_from_pickle(f'{filename}')
            
            nearest_dists = nearest_distances(total_positions[-1,:,:])
            delta_temp = particle_fields - optimal_temp

            ax[1].hist(delta_temp[-1,:]/optimal_temp, alpha=0.5, bins=bins, range=(-0.5,0.5), color=colors[j])
            ax[0].hist(nearest_dists, alpha=0.5, bins=bins, range=(0,1), color=colors[j])
            ax[2].hist(particle_fields[-1,:], alpha=0.5, bins=bins, range=(0,40), color=colors[j])
    
        ax[1].set(xlabel='(T - T$_{opt}$) / T$_{opt}$')
        ax[0].set(xlabel='nearest distance', ylabel='counts')
        ax[2].set(xlabel='T')
        fig.suptitle(f'T$_{{opt}}$ = {np.unique(optimal_temp)[0], np.unique(optimal_temp)[1]}') 
    else:
        fig, ax = plt.subplots(1, 2, figsize=(5,2.2), constrained_layout = True)
        for j,i in enumerate(['_run1.p', '_run2.p', '_run3.p']):
            filename = name + i
            total_positions, particle_fields, optimal_temp, _, _, _ = read_from_pickle(f'{filename}')
            
            nearest_dists = nearest_distances(total_positions[-1,:,:])
            delta_temp = particle_fields - optimal_temp

            ax[1].hist(delta_temp[-1,:]/optimal_temp, alpha=0.5, bins=bins, range=(-0.5,0.5), color=colors[j])
            ax[0].hist(nearest_dists, alpha=0.5, bins=bins, range=(0,1), color=colors[j])
        
        ax[1].set(xlabel='(T - T$_{opt}$) / T$_{opt}$')
        ax[0].set(xlabel='nearest distance', ylabel='counts')
        fig.suptitle(f'T$_{{opt}}$ = {optimal_temp}')
    
    plt.savefig(f'total_hists/{name}_total_observables.png')
    plt.clf()

    return 

def nearest_distances(pos:np.ndarray) -> np.ndarray:
    ''' Computes the distance to the closest neighbour for each of the particles.
        Returns this distance.
    '''
    diff_vectors = np.zeros((pos.shape[0], pos.shape[0], pos.shape[1]))
    for particle in range(pos.shape[0]):
        diff_vectors[particle,:,:] = pos[particle,:] - pos[:,:]

    nearest_dists = np.linalg.norm(diff_vectors[:,:,:], axis=2)
    nearest_dists_inf = np.copy(nearest_dists) # has zeroes for the diagonal (should be in numerator)
    nearest_dists_inf[nearest_dists == 0] = np.inf # has infs for the diagonal (should be in denominator and exponents)
    nearest_dists = np.min(nearest_dists_inf, axis=0)

    return nearest_dists

def read_from_pickle(filename:str) -> tuple[np.ndarray, np.ndarray, Union[float,np.ndarray], float]:
    ''' Reads the data from the pickle file given filename, including extension. Returns the positions, particle fields, optimal temperature, density, timestep size and the sampling factor of saved steps.'''
    try:
        simulation_data = pickle.load(open(f'model_output/{filename}', 'rb'))
    except FileNotFoundError:
        raise FileNotFoundError(f'No data found for model_output/{filename}. Run the simulation first.')
    return simulation_data['positions'], simulation_data['particle_fields'], simulation_data['optimal_temp'], simulation_data['rho'], simulation_data['timestep'], simulation_data['savesampling']

def main():
    if len(sys.argv) != 2:
        print('Usage: python plots.py <filename>')
        sys.exit(1)
    filename = sys.argv[1]

    set_defaults()
    if filename.split('_')[-2] == 'jitterT':
        jitter = True
    else:
        jitter = False

    for appendix in ['_run1.p', '_run2.p', '_run3.p']:
        filename_full = filename + appendix
        total_positions, particle_fields, optimal_temp, rho, timestep, savesampling = read_from_pickle(f'{filename_full}')
        nearest_dists = nearest_distances(total_positions[-1,:,:])
        plot_positions_and_fields(total_positions, particle_fields, optimal_temp, filename_full[:-2], savesampling, timestep)
        plot_field_time(particle_fields, optimal_temp, filename_full[:-2], savesampling, timestep)
        plot_observables(particle_fields, nearest_dists, optimal_temp, filename_full[:-2], jitter=jitter)
    plot_observables_together(filename, jitter=jitter)
        
if __name__ == '__main__':
    main()